\section{Fonctionnalités}
\label{s:fonctionnalités}

\subsection{Image}
\subsubsection{Exportation d'image}
\label{ss:capture_ecran}
Il est possible d'exporter des rendus de la scène dans des fichiers PNG.
Pour ce faire, il suffit d'appuyer sur la barre espace et une capture d'écran de la fenêtre de l'application est sauvegardée dans le dossier \textit{/bin/data}.
Le fichier image est nommé en fonction de la date et de l'heure selon le format y$-$m$-$d\_hms.png.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.1]{fig/2018-3-11_22h34m38s.png}
	\caption{Exemple de capture d'écran}
	\label{fig:capture_ecran}
\end{figure}

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.5]{fig/preuve-capture.png}
	\caption{Fichier exporté}
	\label{fig:preuve-capture}
\end{figure}

L'algorithme de capture d'écran est le suivant:
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.5]{fig/screenshotducodequiprenddesscreenshots.PNG}
	\caption{Code de la capture d'écran}
	\label{fig:code_capture_ecran}
\end{figure}

\subsubsection{Sélecteur de couleur}
\label{ss:selecteur_de_couleur}
L'inspecteur peut afficher un ou plusieurs sélecteurs de couleur, en fonction du type du \emph{GameObject} qui est sélectionné.
Si le \emph{GameObject} possède un attribut qui est une couleur, il y aura dans l'inspecteur un sélecteur qui affiche les valeurs des composantes de couleur de l'attribut et qui permet de les modifier.
Par exemple, pour la lumière, trois sélecteurs de couleur sont affichés, pour ses couleurs diffuse, spéculaire et ambiante, alors que pour une courbe paramétrique, un seul sélecteur permet de modifier la couleur du tracé de la courbe.
Les sélecteurs supportent les espaces RGBA et HSBA.
Chaque composante de couleur est encodée sur 8 bits, ce qui signifie que les sélecteurs acceptent des entiers entre 0 et 255.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{fig/couleur.PNG}
	\caption{Sélecteurs de couleur}
	\label{fig:color_picker}
\end{figure}
Lorsque l'utilisateur entre une valeur dans un des champs, on récupère chacune des composantes et on crée un objet \emph{ofColor} de la librairie \emph{openFrameworks}, qui est ensuite appliqué à l'attribut correspondant dans le \emph{GameObject}.

\subsubsection{Espace de couleur}
Les sélecteurs de couleur de l'inspecteur permettent de travailler en espace RGBA ou en espace HSBA (voir la figure \ref{fig:color_picker}).
Lorsque la valeur d'une composante de couleur est modifiée dans un des espaces, les valeurs du sélecteur dans l'autre espace de couleur sont mises à jour afin d'afficher les valeurs correspondantes.
Les conversions entre les deux espaces de couleur sont gérées par la classe \emph{ofColor} de la librairie \emph{openFrameworks}.


\subsection{Dessin vectoriel}
\subsubsection{Primitives vectorielles}
Les primitives vectorielles offertes par cette application sont : une ligne, un triangle, un rectangle, un pentagone et un cercle.
Sur la figure suivante, on peut voir tous les objets qu'il est possible de créer dans l'application, incluant les primitives vectorielles.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{fig/shapes.PNG}
	\caption{Formes 2D}
	\label{fig:primitives2D}
\end{figure}

\subsubsection{Forme vectorielle}
Les formes vectorielles offertes par cette application sont : une étoile et une flèche.
Sur la figure suivante, on peut voir tous les objets qu'il est possible de créer dans l'application, incluant les formes vectorielles.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{fig/shapes.PNG}
	\caption{Formes 2D}
	\label{fig:formes2D}
\end{figure}

\subsubsection{Interface}
Nous avons décrit en grande majorité le fonctionnement de l’interface utilisateur et de ses éléments dans la section \ref{s:interactivité}.
Nous avons trois éléments d'interface graphique : l’inspecteur (pour modifier la position, la rotation, l’échelle de grandeur, la couleur et le parent des objets), le graphe de scène (voir tous les objets existant dans la scène ainsi que l’objet sélectionné) et l’interface de texture (offerte pour les objets 2D seulement, permettant de changer leur texture).
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/principale.PNG}
	\caption{Interface graphique}
	\label{fig:ui}
\end{figure}

\subsection{Transformation}
\subsubsection{Graphe de scène}
Le graphe de scène est une hiérarchie qui permet d’appliquer la transformation d’un parent sur ses objets enfants. On peut sélectionner un objet sur lequel on veut appliquer une transformation et il permet également de voir tous les éléments existant dans la scène. Pour plus d’information, voir \ref{fig:ui}.
%Le numéro d'un objet de la scène correspond à son ordre dans la liste, débutant à 1.
%Le dernier contrôle présent dans l'inspecteur est un champ de nombre entier permettant de sélectionner le parent de l'objet sélectionné dans le graphe de scène.
%Cette valeur doit être comprise entre 0 et le nombre d'objets dans la scène inclusivement, 0 signifiant que l'objet n'a pas de parent.
%Un nombre supérieur à 0 représente le numéro de l'objet parent dans la liste des objets de la scène, 1 étant le premier, 2 le deuxième et ainsi de suite.
%Un objet ne peut pas être son propre parent ni être l'enfant d'un de ses enfants.\\

\subsubsection{Transformations interactives}
L’interface utilisateur (le panneau Inspecteur) permet de façon interactive de changer la position, la rotation, la couleur, l’échelle de grandeur et le parent de l’objet sélectionné. Pour plus d’informations, se référer à \ref{fig:ui}.
%La position est modifiée à l'aide de trois champs de textes permettant d'entrer des valeurs numériques entre -1000 et 1000 pour les composantes x, y et z.
%Si l'utilisateur entre une valeur à l'extérieur de cette intervalle, celle-ci est ramenée à la limite la plus proche.
%S'il entre un caractère non numérique (sauf le signe moins), alors le champ est remis à 0.
%La rotation d'objet est modifiée à l'aide de trois glisseurs permettant de sélectionner une valeur entre -180 et 180 degrés pour chacun des angles d'Euler.
%L'échelle est modifiée à l'aide de trois champs de textes similaires à ceux pour la position, mais limités entre -100 et 100. Les valeurs de position, de rotation et d'échelle affichées dans l'inspecteur sont dans le référentiel local de l'objet sélectionné, ce qui veut dire que s'il est enfant d'un autre objet, les valeurs affichées seront par rapport au parent et non par rapport au référentiel global de la scène.\\

\subsubsection{Historique des transformations}
\paragraph{} L'historique de transformation permet d'annuler et de récupérer une action provenant de l'utilisateur. Pour l'application, il est possible d'avoir l'historique du déplacement, de la rotation, de l'échelle et de la couleur pour chaque objet avec les touches \texttt{Ctrl+Z} et \texttt{Ctrl+Y}.
\paragraph{} L'état d'un objet \texttt{GameObject} est sauvegardé dans une classe \texttt{Command} à chacunes de ces actions. Le nombre de sauvegarde de commande est limité à 500. Cette commande est gérée par la classe \texttt{CommandHandler} qui s'occupe de sauvegarder les états courants (\texttt{CommandHandler::add()}), d'appliquer les changements d'état (\texttt{CommandHandler::undo()/redo()}) et d'ordonner les commandes dans deux \texttt{std::stack} dont une pour récupérer les commandes et une autre pour les annuler. Cette classe appartient à la classe \texttt{Scene} qui appelle la méthode de sauvegarde d'état à chaque fonction de modification d'un \texttt{GameObject}. Elle offre aussi les méthodes \texttt{Scene::undo()} et \texttt{Scene::redo()} pour que les événements puissent contrôler l'historique des transformations.

\subsection{Géométrie}
\subsubsection{Boîte de délimitation}
La boîte de délimitation permet de dessiner les arètes d’une boîte juste assez grande pour contenir les sommets d’un objet. Par contre, le Faucon Millénium et le « XWing » n’ont pas de boîte de délimitation car la position des sommets à l’intérieur du « mesh » est décalée par rapport au modèle 3D, ce qui dessinait la boîte très loin des objets eux-mêmes.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/delimitation.PNG}
	\caption{Boîte de délimitation}
	\label{fig:box}
\end{figure}

\subsubsection{Primitives géométriques}
Les primitives géométriques offertes par cette application sont : un cube et une sphère.
Sur la figure suivante, on peut voir tous les objets qu'il est possible de créer dans l'application, incluant les primitives géométriques.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{fig/shapes.PNG}
	\caption{Primitives géométriques}
	\label{fig:primitivesgeo}
\end{figure}

\subsubsection{Modèle 3D}
Les modèles 3D offerts par cette application sont : le \textit{Faucon Millenium} et le \textit{X-Wing Fighter}.
Sur la figure suivante, on peut voir tous les objets qu'il est possible de créer dans l'application, incluant les modèles 3D.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{fig/shapes.PNG}
	\caption{Modèles 3D}
	\label{fig:modeles3D}
\end{figure}

\subsection{Texture}
\subsubsection{Mapping}
Les modèles 3D du \textit{Faucon Millenium} ainsi que du \textit{X-Wing Fighter} sont texturés avec des coordonnées de mapping contenues dans leur fichier .OBJ respectif.
Le add$-$ons \textit{ofxAssimpModel} permet de charger ces modèles et s'occupe de créer les coordonnées de textures correspondant à chaque sommet.
Sur la figure suivante, on peut voir les deux modèles avec leur texture appliquée adéquatement.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/shapes.PNG}
	\caption{Modèles 3D texturés}
	\label{fig:mapping}
\end{figure}

Chaque forme 2D qu'il est possible de créer (ligne, rectangle, triangle, cercle, pentagone, flèche et étoile) possède des coordonnées de texture permettant de leur associer les textures procédurales.
Par exemple, la figure suivante montre l'étoile texturée.
\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/star.PNG}
	\caption{Étoile texturée}
	\label{fig:mapping2}
\end{figure}



\subsubsection{Texture procédurale}
\paragraph{} Les textures procédurales proviennent d'un patron de base sur lequel est appliqué des algorithmes. Les patrons de bases utilisés sont le bruit de perlin, le patron en sinus et le patron en cercle.
\paragraph{} Il est possible de générer une texture procédurale imitant l'effet nuage avec le bruit de perlin, une interpolation linéaire, un algorithme de turbulence et une modification les paramètres HSL. L'effet marbre est généré par le patron en sinus sur lequel on applique un algorithme de turbulence. L'effet bois est généré par le patron en cercle sur lequel on applique un algorithme de turbulence ainsi qu'un filtre de couleur bois (orangé / brun).
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{img/infog-image-procedural-texture.png}
\caption{Textures procédurales}\label{fig-procedural-texture}
\end{figure}
\paragraph{} Au niveau de l'application, une classe \texttt{texelFactory} s'occupe de générer toutes les textures procédurales présentées plus-haut (\ref{fig-procedural-texture}).  Chaque textue est interfacée par une méthode permettant de transformer un buffer \texttt{ofPixels} avec des paramètres (puissance de la turbulence par exemple) qui seront utilisées par les algorithmes correspondants (réf. \ref{src-procedural-texture}). Par la suite, ce buffer est appliqué sur le \texttt{GameObject} qui possède un \texttt{ofTexture} et un \texttt{ofMesh} propre. Aussi, lors de la création du \texttt{ofMesh}, il est nécessaire de cartographier la texture sur la forme avec la méthode \texttt{ofMesh::addTextCoord} et \texttt{ofTexture::getCoordFromPercent}.

%%%%%%%%%%%%%%      TP2      %%%%%%%%%%%%
\subsection{Caméra}
\subsubsection{Point de vue}
\label{s:pov}
Il est possible de déplacer la caméra afin d'avoir un point de vue différent de la scène.
Pour ce faire, nous avons utilisé la classe \emph{ofCamera} de la librairie \emph{openFrameworks}.
Il est donc possible de déplacer la caméra par rapport à ses axes X, Y et Z locaux au moyen des touches \textbf{w}, \textbf{a}, \textbf{s}, \textbf{d}, \textbf{+} et \textbf{-}.
De plus, il est possible de faire tourner la caméra autour de ses axes X et Y locaux à l'aide des flèches du clavier.
Enfin, la touche \textbf{r} permet de réinitialiser la caméra à sa pose initiale.
Les figures \ref{fig:scenePOV1} et \ref{fig:scenePOV2} montre la même scène sous deux points de vue différents.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.25]{fig/scenePOV1.png}
	\caption{Scène}
	\label{fig:scenePOV1}
\end{figure}

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.22]{fig/scenePOV2.png}
	\caption{Autre point de vue de la scène}
	\label{fig:scenePOV2}
\end{figure}

\subsubsection{Mode de projection}
\label{s:projection}
L'application supporte deux modes de projection de caméra: perspective et orthogonale.
Pour alterner entre les deux, il suffit d'appuyer sur la touche \textbf{c}.
La classe \emph{ofCamera} d'\emph{openFrameworks} permet de passer d'un mode à l'autre à l'aide d'une seule méthode.
Cependant, dans le mode perspective, les dimensions des \emph{GameObject} sont en unités de scène, alors qu'en mode orthogonale, elles sont en pixels.
Pour compenser, nous appliquons un facteur d'échelle global de 100x au début de chaque appel à la fonction de dessin de la scène si la caméra est en mode orthogonale.
Les figures \ref{fig:perspective} et \ref{fig:orthogonale} montre le même point de vue d'une scène avec respectivement le mode de projection en perspective et orthogonale.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.25]{fig/scenePOV1.png}
	\caption{Projection en perspective}
	\label{fig:perspective}
\end{figure}

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.25]{fig/orthogonale.png}
	\caption{Projection orthogonale}
	\label{fig:orthogonale}
\end{figure}


\subsubsection{Portail}
\label{s:portail}
Notre application possède une classe spéciale de \emph{GameObject} qui implémente un portail inspiré du jeu \emph{Portals}.
Ces portails sont créés en paire et il ne peut y en avoir que deux dans la scène.
Comme dans le jeu \emph{Portals}, ce qui est affiché dans un portail correspond au point de vue de la scène à partir de l'autre portail.
Pour réaliser cet effet, deux plans et une autre caméra, indépendante de la caméra principale, sont requis.

Lorsque les portails sont mis à jour, on applique la transformation du premier portail à la caméra et on rend la scène dans un objet \emph{ofFbo}.
On extrait ensuite l'image de ce \emph{ofFbo} et on l'applique au plan du second portail sous la forme d'une texture.
On répète ensuite ces étapes en inversant le portail qui génère la texture et celui qui la reçoit.
Lorsque la méthode de dessin de la scène est appelée, on rend les deux plans de la même manière qu'on rend les autres \emph{GameObject} texturés.
La figure \ref{fig:code_portals} présente le code permettant de mettre à jour la texture des deux portails (la classe d'un portail s'appelle \emph{Mirror}, nous avons oublié de changer le nom!).

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{fig/code_portals.png}
	\caption{Code de la mise à jour des portails}
	\label{fig:code_portals}
\end{figure}

L'image de chacun des portails change donc en temps réel et on peut y voir les autres éléments de la scène.
La figure \ref{fig:portals} montre une scène avec les deux portails et une sphère bleue.
La sphère se trouve devant le portail de droite et on peut la voir dans le portail de gauche.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/portals.png}
	\caption{Scène avec les deux portails et une sphère}
	\label{fig:portals}
\end{figure}

% >> ILLUMINATION
\subsection{Illumination}
\subsubsection{Modèle d'illumination}
\label{s:illumination}

%Les modèles d'iilumination choisi sont \textit{remplissage de couleur}, \textit{lambert}, \textit{gouraud}, \textit{phong} et \textit{blinn-phong}. Dans la scène, il est possible de passer d'un modèle d'illumination à l'autre grâce à la touche \textbf{'q'}. Ces modèles sont appliqués aux primitives avec des \textit{shaders} qui se trouvent dans le dossier \textit{bin/data/shadersRender}. Il est représenté par la classe \texttt{Render} qui se trouve à l'intérieur de la classe \texttt{Scene}. Le \textit{shader} est appliqué sur tous les \texttt{GameObject} lors de l'appel de la fonction \texttt{Scene::draw()}.
%
%\begin{figure}[H]
%    \centering
%	\includegraphics[scale=0.6]{img/infog-image-modele-illumination.png}
%	\caption{Rendu des modèles d'illumination}
%	\label{fig:illuminationmodel}
%\end{figure}

\subsubsection{Matériaux}
\label{s:materiaux}

\subsubsection{Types de lumières}
\label{lumiere}

% >> LANCER DE RAYON
\subsection{Lancer de rayon}

Aucun critère fonctionnel n'a été réalisé dans ce module.

% >> TOPOLOGIE
\subsection{Topologie}
\subsubsection{Courbe cubique}
\label{s:courbe_cubique}
L'application offre la possibilité de créer deux types de courbes cubiques avec 4 points de contrôle, soient des courbes de Bézier ou des courbes de Hermite.
Elles sont créées avec les touches \textbf{b} et \textbf{n} respectivement.

La classe abstraite \emph{Curve} implémente la gestion des points de contrôle et le dessin de la courbe, mais délègue aux classes \emph{BezierCurve} et \emph{HermiteCurve} la responsabilité d'implémenter la fonction d'interpolation.
Les équations vues en classe ont été utilisées pour chacune des courbes.
Les figures \ref{fig:courbe_bezier} et \ref{fig:courbe_hermite} montre respectivement les courbes de Bézier et de Hermite créées par défaut.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/bezier.png}
	\caption{Courbe de Bézier}
	\label{fig:courbe_bezier}
\end{figure}

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/hermite.png}
	\caption{Courbe de Hermite}
	\label{fig:courbe_hermite}
\end{figure}

Les points de contrôle sont des \emph{GameObjects}, ce qui permet de les afficher dans le panneau de scène et de les sélectionner.
L'utilisateur peut donc déplacer les points de contrôle à sa guise, ce qui modifie la forme de la courbe.
La figure \ref{fig:courbe_bezier2} montre une courbe de Bézier dont la position du deuxième point de contrôle a été modifiée.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/bezier2.png}
	\caption{Courbe de Bézier avec un point de contrôle déplacé}
	\label{fig:courbe_bezier2}
\end{figure}

\subsubsection{Courbe paramétrique}
\label{s:courbe_parametrique}
La courbe de Bézier supporte l'ajout dynamique de points de contrôle.
En effet, nous avons utilisé l'équation polynomiale de \emph{Bernstein} (voir figure \ref{fig:code_bezier}).

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.5]{fig/code_bezier.png}
	\caption{Équation générale de la courbe de Bézier}
	\label{fig:code_bezier}
\end{figure}

Un bouton s'affiche dans l'inspecteur si une courbe de Bézier est sélectionnée afin de lui ajouter un nouveau point de contrôle.
Ce nouveau point est ajouté à la fin de la liste de points de la courbe et il est placé à la position (0,0,0) dans son référentiel.
L'utilisateur peut ensuite sélectionner ce nouveau point dans le panneau de scène et le déplacer.
La figure \ref{fig:courbe_bezier3} montre la courbe de Bézier de base, à laquelle on a ajouté deux points de contrôle.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.4]{fig/bezier3.png}
	\caption{Courbe de Bézier avec 2 nouveaux point de contrôle}
	\label{fig:courbe_bezier3}
\end{figure}


\subsection{Techniques de rendu}
\subsubsection{Effet en pleine fenêtre}
\label{s:effect}
Les effets en pleine fenêtre sont gérés par la classe \texttt{fboRender}. Cette classe permet d'appliquer 4 types d'effet visuel dont un effet \textbf{flou gaussien}, un effet \textbf{noir et blanc}, un effet \textbf{gris} et un effet \textbf{sépia}. Il est possible de passer d'un effet à un autre avec la touche \textbf{'e'} lorsque le logiciel est lancé. \\

Chaque effet est géré par son propre shader qui se trouve dans le dossier \texttt{bin/data/shaders} qui contient les fichiers \textit{Vertex Shader} et \textit{Fragment Shader}. Le principe est de dessiner la scène dans un élément \texttt{ofFbo} pour rastériser le plan image afin d'appliquer par la suite le \texttt{shader} approprié. Enfin, on dessine l'objet \texttt{ofFbo} pour afficher le résultat à l'écran.

\begin{figure}[H]
    \centering
	\includegraphics[scale=1]{img/infog-image-effet-plein-ecran.png}
	\caption{Application des effets sur la scène en cours.}
	\label{fig:effects}
\end{figure}


\subsubsection{Effet de relief}
\label{s:relief}
La technique d'effet en relief choisi est un mélange entre du \textit{normal mapping} et du \textit{bump mapping} sur un mur de brique de pierre. Cet effet de relief est représenté par la classe \texttt{planeRelief} qui contient le \texttt{ofShader} qui applique les fichiers \textit{normalMap.frag/vert}, des \texttt{ofImage} pour charger la texture, la texture \textit{bump mapping} et la texture \textit{normal mapping}. Le \textit{shader} assigne les textures, la profondeur maximum et la position de la lumière qui sont ensuite appliqué sur la primitive \texttt{ofPlanePrimitive}.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.8]{img/infog-image-mur-pierre.png}
	\caption{Fichiers textures du mur de pierre.}
	\label{fig:wallfiles}
\end{figure}

La texture \textbf{Bump Map} sert à ajouter de la profondeur en repositionnant chaque point de la surface en fonction de la valeur de ce point sur la texture \textbf{Bump Map} avec une profondeur fixée par une variable, ce qui donne l'\textbf{Effet Bump Map} ci-dessous. \\

La texture \textbf{Normal Map} sert à ajouter un effet relief grâce à la position de la lumière ambiante par rapport à la normal de la surface qui est représenté par la valeur des canaux RGB de la texture \textbf{Normal Map}. L'ombrage de chaque pixel est calculé par la suite grâce à la position de la lumière et de la normal à ce point, ce qui donne l'\textbf{Effet Normal map} ci-dessous.

\begin{figure}[H]
    \centering
	\includegraphics[scale=0.62]{img/infog-image-rendu-mur-pierre.png}
	\caption{Rendu des effets de relief sur le mur de pierre}
	\label{fig:wallnormalbumprender}
\end{figure}

\subsubsection{Style libre}

Le style libre est l'effet visuel cartoon en temps réel qui fait partie de la classe \texttt{fboRender}.
Cet effet est inspiré du look cartoon de la série de jeux vidéo \emph{Borderlands}.
Il s'agit d'une combinaison d'effet gérée par des \textit{shaders} qui permet d'arriver à ce résultat.
La figure \ref{fig:cartooneffect} compare le rendu d'une scène sans effet pleine fenêtre avec le rendu de la même scène avec l'effet cartoon.
On parcourt les différents effet pleine fenêtre en appuyant sur la touche \textbf{'e'}.\\

Trois traitements principaux sont identifiés :
\begin{itemize}
\item \textbf{Baisse de la résolution des couleurs originales}\\
Cette baisse de résolution se fait par le \textit{shaders/colorbits.frag} qui va la réduire à 4 valeurs pour chaque canal RGB.
\item \textbf{Détection des lignes de contours}\\
Cette phase applique deux traitements à l'image d'origine dont l'application du \textit{shaders/blackwhite.frag} pour obtenir l'image en noire et blanche suivi d'un détecteur de contours (Filtre de Sobel) avec \textit{shaders/edgesobel.frag}.
\item \textbf{Combinaison des deux images}\\
Il s'agit d'une simple multiplication entre la texture avec détection de contours et la texture à basse résolution grâce à au \textit{shaders/multiple.frag}. \\
\end{itemize}

Chacune des étapes se fait par le biais d'un objet \texttt{ofFbo} pour chaque application de \textit{shader}.


\begin{figure}[H]
    \centering
	\includegraphics[scale=1]{img/infog-image-effet-cartoon.png}
	\caption{Rendu de l'effet cartoon sur une scène}
	\label{fig:cartooneffect}
\end{figure}
\clearpage
